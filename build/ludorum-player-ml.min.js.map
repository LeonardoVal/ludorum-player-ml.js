{"version":3,"sources":["../src/__prologue__.js","../src/GameModel.js","../src/GameClassifier.js","../src/classifiers/ParametricalGameClassifier.js","../src/classifiers/RuleBasedGameClassifier.js","../src/classifiers/LinearGameClassifier.js","../src/players/ActionClassifierPlayer.js","../src/players/ResultClassifierPlayer.js","../src/games/tictactoe.js","../src/__epilogue__.js","../src/training/ParametricalGameClassifierOptimizationProblem.js"],"names":["__init__","base","Sermat","ludorum","declare","raiseIf","iterable","Iterable","unimplemented","objects","initialize","Player","HeuristicPlayer","players","exports","__package__","__name__","__dependencies__","classifiers","games","training","GameModel","constructor","params","this","object","ignore","actionClasses","game","moves","activePlayer","actionForClass","actionClass","role","resultClasses","chain","resultBounds","sorted","toArray","resultForClass","resultClass","features","featureRanges","normalizedFeatures","player","min","max","isNaN","d","zip","mapApply","f","r","GameClassifier","args","array","gameModel","classes","random","Randomness","DEFAULT","classify","classify_randomMatch","classify_firstMatch","matches","length","choice","match_bestEvaluated","evaluate","greater","clazz","map","normalizedEvaluate","evals","Infinity","count","forEachApply","c","v","static actionClassifier","members","prototype","copy","classifier","ActionClassifierPlayer","static resultClassifier","hasOwnProperty","heuristic","ResultClassifierPlayer","bind","AlphaBetaPlayer","ParametricalGameClassifier","call","parameterRanges","parameters","p","i","ClassifierType","Object","assign","static randomClassifier","RuleBasedGameClassifier","LinearGameClassifier","featureCount","__parameters__","range","slice","w","x","sum","paramCount","actionClassifier","repeat","possibleResults","resultClassifier","__rules__","rules","match_rules","ruleContext","rule","indexOf","evaluate_rules","counts","toObject","done","forEach","level","dual ruleFromValues","values","metadata","ruleFunction","all","add_ruleFromValues","push","ruleFromValues","dual parseActions","levels","chars2Features",".","+","_","-","self","vs","k","split","chars","fs","chr","class","match","decision","validMoves","action","static heuristic","divisor","Math","abs","tictactoe","TicTacToeGameModel","TicTacToe","__featureRanges__","charAt","factor","board","sq","MODEL","ACTION_RULES","parseActions","4","0|2|6|8","0","2","3","5","6","8","ruleBasedActionPlayer","RESULT_RULES","ruleBasedResultPlayer","getParametricalGameClassifierOptimizationProblem","inveniemus","Problem","require","Measurement","RandomPlayer","tournaments","objectives","precision","matchCount","func","integer","coerce","opponents","__initOpponents__","title","description","elementModel","n","Element","emblem","evaluation","e","round","join","String","fromCharCode","Future","then","problem","__evaluationCount__","elem","dual opponentFromString","str","toLowerCase","name","test","h","substr","horizon","s","MonteCarloPlayer","simulationCount","timeCap","raise","opponent","opponentFromString","mapping","element","tournament","run","stats","statistics","key","elements","geneticAlgorithm","mh","metaheuristics","GeneticAlgorithm","mutationRate","size","steps","events","on","state"],"mappings":";;wTAEA,SAASA,EAASC,EAAMC,EAAQC,GAAU,aAGzC,IAAIC,EAAUH,EAAKG,QAClBC,EAAUJ,EAAKI,QACfC,EAAWL,EAAKK,SAChBC,EAAWN,EAAKM,SAChBC,EAAgBP,EAAKQ,QAAQD,cAC7BE,EAAaT,EAAKS,WAElBC,EAASR,EAAQQ,OACjBC,EAAkBT,EAAQU,QAAQD,gBAG/BE,GACFC,YAAa,oBACbC,SAAU,oBACVhB,SAAUA,EACViB,kBAAmBhB,EAAMC,EAAQC,IAElCe,EAAcJ,EAAQI,eACtBL,EAAUC,EAAQD,WAClBM,EAAQL,EAAQK,SAChBC,EAAWN,EAAQM,YCpBjBC,EAAYP,EAAQO,UAAYjB,GACnCkB,YAAa,SAAmBC,GAC/Bb,EAAWc,KAAMD,GAGfE,OAAM,QAAWC,QAAQ,KAQ5BC,cAAe,SAAuBC,GAErC,OADAA,EAAOA,GAAQJ,KAAKI,MACRC,QAAQD,EAAKE,iBAG1BC,eAAgB,SAAwBC,EAAaJ,EAAMK,GAC1D,OAAOD,GAORE,cAAe,SAAuBN,GAErC,OADAA,EAAOA,GAAQJ,KAAKI,KACb3B,EAAKM,SAAS4B,OAAO,GAAIP,EAAKQ,gBAAgBC,SAASC,WAG/DC,eAAgB,SAAwBC,EAAaZ,EAAMK,GAC1D,OAAOO,GAQRC,SAAUjC,EAAa,YAAc,yBAKrCkC,cAAelC,EAAa,YAAc,uBAO1CmC,mBAAoB,SAA4Bf,EAAMgB,EAAQC,EAAKC,GAClED,EAAME,MAAMF,GAAO,GAAKA,EAExB,IAAIG,GADJF,EAAMC,MAAMD,GAAO,GAAKA,GACVD,EACd,OAAOtC,EAAS0C,IAAIzB,KAAKiB,SAASb,EAAMgB,GAASpB,KAAKkB,iBACpDQ,SAAS,SAAUC,EAAGC,GACtB,OAAQD,EAAIC,EAAEP,MAAQO,EAAEN,IAAMM,EAAEP,KAAOG,EAAIH,IACzCP,aC3DFe,EAAiBvC,EAAQuC,eAAiBjD,GAI7CkB,YAAa,SAAwBgC,GACpC5C,EAAWc,KAAM8B,GAIf7B,OAAM,aAAgBC,QAAQ,IAI9B6B,MAAK,WAAc7B,QAAQ,IAG3BD,OAAM,UAAaC,QAAQ,KAM9B8B,UAAW,KAGXC,WAKAC,OAAQzD,EAAK0D,WAAWC,QAMxBC,SAAU,SAAkBjC,EAAMgB,GACjC,OAAOpB,KAAKsC,qBAAqBlC,EAAMgB,IAKxCmB,oBAAqB,SAA6BnC,EAAMgB,GACvD,IAAIoB,EAAUxC,KAAKwC,QAAQpC,EAAMgB,GACjC,OAAOoB,EAAQC,OAAS,EAAID,EAAQ,GAAK,MAG1CF,qBAAsB,SAA8BlC,EAAMgB,GACzD,IAAIoB,EAAUxC,KAAKwC,QAAQpC,EAAMgB,GACjC,OAAOoB,EAAQC,OAAS,EAAIzC,KAAKkC,OAAOQ,OAAOF,GAAW,MAU3DA,QAAS,SAAiBpC,EAAMgB,GAC/B,OAAOpB,KAAKiC,SAMbU,oBAAqB,SAA6BvC,EAAMgB,GACvD,IAAIa,EAAUjC,KAAKiC,QACnB,OAAOnD,EAASkB,KAAK4C,SAASxC,EAAMgB,IAASyB,QAAQ,SAAUC,GAC9D,OAAOA,EAAM,KACXC,IAAI,SAAUD,GAChB,OAAOb,EAAQa,EAAM,OAUvBF,SAAU,SAAkBxC,EAAMgB,GACjC,IAAIc,EAASlC,KAAKkC,OAClB,OAAOlC,KAAKiC,QAAQc,IAAI,SAAUD,GACjC,OAAQA,EAAOZ,EAAOA,aAMxBc,mBAAoB,SAA4B5C,EAAMgB,GACrD,IAAI6B,EAAQnE,EAASkB,KAAK4C,SAASxC,EAAMgB,IACxCC,EAAO6B,EAAAA,EACP5B,GAAO4B,EAAAA,EACPC,EAAQ,EACTF,EAAMG,aAAa,SAAUC,EAAGC,GAC3BjC,EAAMiC,IACTjC,EAAMiC,GAEHhC,EAAMgC,IACThC,EAAMgC,GAEPH,MAED,IAAI3B,EAAIF,EAAMD,EACd,OAAO4B,EAAMvB,SAAS,SAAU2B,EAAGC,GAClC,OAAQD,GAAIC,EAAIjC,IAAQG,GAAKF,GAAO,GAAK6B,KACvCrC,WAQJyC,0BAA2B,SAA0BC,GACpD,IAAIxB,EAAYwB,EAAQxB,WAAahC,KAAKyD,UAAUzB,UAYpD,OAXAnD,GAASmD,EAAW,4BACpBwB,EAAU/E,EAAKiF,QAASF,GACtBvB,QAASD,EAAU7B,gBAInBiB,OAAQ,SAAgBrB,GAEvB,OADAA,EAAStB,EAAKiF,QAAS3D,GAAU4D,WAAY3D,OACtC,IAAI4D,EAAuB7D,MAG9BnB,EAAQoB,KAAMwD,IAMtBK,0BAA2B,SAA0BL,GACpD,IAAIxB,EAAYwB,EAAQxB,WAAahC,KAAKyD,UAAUzB,UAgBpD,OAfAnD,GAASmD,EAAW,4BACpBwB,EAAU/E,EAAKiF,QAASF,GACtBvB,QAASD,EAAUtB,gBAInBU,OAAQ,SAAgBrB,GAEvB,OADAA,EAAStB,EAAKiF,QAAS3D,GAAU4D,WAAY3D,QAClC8D,eAAc,YACxB/D,EAAOgE,UAAYC,EAAuBD,UAAUE,KAAK,KAAMjE,MACxD,IAAIrB,EAAQU,QAAQ6E,gBAAgBnE,IAErC,IAAIiE,EAAuBjE,MAG9BnB,EAAQoB,KAAMwD,MCxJnBW,EAA6BzE,EAAYyE,2BAA6BvF,EAAQiD,GAGjF/B,YAAa,SAAoCgC,GAChDD,EAAeuC,KAAKpE,KAAM8B,GAC1B,IAAIuC,EAAkBrE,KAAKqE,gBAC1BC,EAAaxC,EAAKwC,eACnBzF,EAAQyF,EAAW7B,SAAW4B,EAAgB5B,OAC7C,YAAa4B,EAAgB5B,OAAQ,wBAAyB6B,EAAW7B,OAAQ,KAClF1D,EAAS0C,IAAI6C,EAAYD,GAAiBjB,aAAa,SAAUmB,EAAG3C,EAAG4C,GACtE3F,EAAQ0F,EAAI3C,EAAEP,KAAOkD,EAAI3C,EAAEN,IAAK,SAAUiD,EAAG,kBAAmBC,EAAG,kBAClE5C,EAAEP,IAAK,IAAKO,EAAEN,IAAK,QAErBtB,KAAKsE,WAAaA,GAMnBD,mBAKA7B,QAASX,EAAe4B,UAAUd,oBAKlCY,0BAA2B,SAA0BkB,EAAgBzC,EAAWqC,GAG/E,OAFAxF,EAAkC,mBAAnB4F,EAA+B,2BAC9C5F,GAASwF,EAAiB,4BACnBzF,EAAQ6F,GACdzC,UAAWA,EACXC,QAASD,EAAU7B,gBACnBkE,gBAAiBA,EAIjBjD,OAAQ,SAAgBrB,GACvB,OAAO,IAAI6D,EAAuBc,OAAOC,OAAO5E,OAC/C4D,WAAY3D,YAShB6D,0BAA2B,SAA0BY,EAAgBzC,EAAWqC,EAAiB3D,GAGhG,OAFA7B,EAAkC,mBAAnB4F,EAA+B,2BAC9C5F,GAASwF,EAAiB,4BACnBzF,EAAQ6F,GACdzC,UAAWA,EACXC,QAASvB,GAAiBsB,EAAUtB,gBACpC2D,gBAAiBA,EAMjBjD,OAAQ,SAAgBrB,GAIvB,OAHAA,EAAS2E,OAAOC,OAAO5E,OACtB4D,WAAY3D,QAEF8D,eAAc,YACxB/D,EAAOgE,UAAYC,EAAuBD,UAAUE,KAAK,KAAMjE,MACxD,IAAIrB,EAAQU,QAAQ6E,gBAAgBnE,IAErC,IAAIiE,EAAuBjE,OAOrC6E,0BAA2B,SAA0B1C,GACpDA,EAASA,GAAUlC,KAAKyD,UAAUvB,OAClC,IAAImC,EAAkBrE,KAAKyD,UAAUY,gBAKrC,OAJAxF,GAASwF,EAAiB,qCAInB,IAAIrE,MAAOsE,WAHLD,EAAgBtB,IAAI,SAAUnB,GAC1C,OAAOM,EAAOA,OAAON,EAAEP,IAAKO,EAAEN,YCjF7BuD,GCAuBnF,EAAYoF,qBAAuBlG,EAAQuF,GACrErE,YAAa,SAA8BgC,GAC1CqC,EAA2BC,KAAKpE,KAAM8B,GACtC,IAAIwC,EAAaxC,GAAQA,EAAKwC,WAC7BS,EAAe/E,KAAKgC,UAAUd,gBAAgBuB,OAC/CzC,KAAKgF,eAAiBjG,EAASkG,MAAMjF,KAAKiC,QAAQQ,QAAQM,IAAI,SAAUyB,GACvE,OAAOF,EAAWY,MAAMV,EAAIO,GAAeP,EAAI,GAAKO,KAClDjE,WAMJ8B,SAAU,SAAkBxC,EAAMgB,GACjC,IAAIH,EAAWjB,KAAKgC,UAAUb,mBAAmBf,EAAMgB,GACvD,OAAOtC,EAASkB,KAAKgF,gBAAgBjC,IAAI,SAAUhD,EAAQyE,GAIzD,OAAQA,EAHAzF,EAAS0C,IAAI1B,EAAQkB,GAAUS,SAAS,SAAUyD,EAAGC,GAC5D,OAAOD,EAAIC,IACTC,SAEDvE,WAMLyC,0BAA2B,SAA0BvB,GACpD,IAECsD,EAFkBtD,EAAUd,gBAAgBuB,OAClCT,EAAU7B,gBACgBsC,OACrC,OAAO0B,EAA2BoB,iBAAiBvF,KAAMgC,EACxDjD,EAASyG,QAASnE,KAAM,EAAGC,IAAK,GAAMgE,GAAYxE,YAOpD+C,0BAA2B,SAA0B7B,EAAWyD,GAC/D,IAECH,EAFkBtD,EAAUd,gBAAgBuB,QAClCgD,GAAmBzD,EAAUtB,iBACH+B,OACrC,OAAO0B,EAA2BuB,iBAAiB1F,KAAMgC,EACxDjD,EAASyG,QAASnE,KAAM,EAAGC,IAAK,GAAMgE,GAAYxE,UAClD2E,MD5C2B/F,EAAYmF,wBAA0BjG,EAAQiD,GAC3E/B,YAAa,SAAiCgC,GAC7CD,EAAeuC,KAAKpE,KAAM8B,GAC1B9B,KAAK2F,UAAY7D,GAAQA,EAAK8D,WAO/BA,MAAO,WACN,OAAO5F,KAAK2F,WAGbA,aAEAtD,SAAUR,EAAe4B,UAAUlB,oBAKnCsD,YAAa,SAAqBzF,EAAMK,EAAMmF,EAAOE,GACpDF,EAAQA,GAAS5F,KAAK4F,QAItB,IAHA,IAAI3E,EAAWjB,KAAKgC,UAAUf,SAASb,EAAMK,GAC5CwB,EAAUjC,KAAKiC,QACfO,KACQgC,EAAI,EAAGhC,EAAQC,OAAS,GAAK+B,EAAIoB,EAAMnD,OAAQ+B,IACvDhC,EAAU1D,EAAS8G,EAAMpB,IAAIzB,IAAI,SAAUgD,GAC1C,OAAOA,EAAK3B,KAAK0B,EAAa7E,EAAUb,EAAMK,IAC5C,SAAUqC,GACZ,OAAOb,EAAQ+D,QAAQpE,IAAM,IAC3Bd,UAEJ,OAAO0B,GAKRyD,eAAgB,SAAwB7F,EAAMK,EAAMmF,EAAOE,GAC1DF,EAAQA,GAAS5F,KAAK4F,QAKtB,IAJA,IAAI3E,EAAWjB,KAAKgC,UAAUf,SAASb,EAAMK,GAC5CyF,EAASnH,EAAS0C,IAAIzB,KAAKiC,QAASlD,EAASyG,OAAO,IAAIW,WACxDC,GAAO,EAEC5B,EAAI,GAAI4B,GAAQ5B,EAAIoB,EAAMnD,OAAQ+B,IAC1CoB,EAAMpB,GAAG6B,QAAQ,SAAUC,GAC1B,IAAIjD,EAAI0C,KAAK3B,KAAK0B,EAAa7E,EAAUb,EAAMK,QAC9B,IAAN4C,GAA2B,OAANA,IAC/B6C,EAAO7C,KACP+C,GAAO,KAIV,OAAOtH,EAASoH,GAAQpF,WAKzByF,sBAAuB,SAAwBC,EAAQ1D,EAAO2D,GAC7D,IAAIC,EAAe,SAAUzF,GAK5B,OAJalC,EAAS0C,IAAIR,EAAUuF,GAAQG,IAAI,SAAUpC,GACxD,IAAI5C,EAAI4C,EAAE,GAAIjB,EAAIiB,EAAE,GACpB,YAAqB,IAANjB,GAA2B,OAANA,GAAc3B,IAAM2B,IACpDR,EAAQ,MAIf,OADA4B,OAAOC,OAAO+B,EAAcD,GACrBC,GAGRE,mBAAoB,SAA4BJ,EAAQ1D,EAAO2D,GAE9D,OADAzG,KAAK2F,UAAUkB,KAAK7G,KAAK8G,eAAeN,EAAQ1D,EAAO2D,IAChDzG,MAGR+G,oBAAqB,SAAsBC,EAAQC,GAClDA,EAAiBA,IAChBC,IAAK,KACLC,IAAK,EAAIC,EAAM,EAAGC,KAAM,GAEzB,IAAIC,EAAOtH,KAEX,OAAOgH,EAAOjE,IAAI,SAAUuD,GAC3B,IACCiB,EADG3F,KAEJ,IAAK,IAAI4F,KAAKlB,EACbiB,EAAKjB,EAAMkB,GACXA,EAAEC,MAAK,KAAMpB,QAAQ,SAAUvD,GAC9ByE,EAAGE,MAAK,OAAQpB,QAAQ,SAAUqB,GACjC,IAAIC,EAAKD,EAAMD,MAAK,IAAK1E,IAAI,SAAU6E,GACrC,OAAOX,EAAeW,KAEvBvE,IAAgB,MAAVP,EAAgB,EAAe,MAAVA,GAAiB,EAAIA,GAChDiD,EAAOuB,EAAKR,eAAea,EAAItE,GAAKpC,SAAU0G,EAAIE,MAAOxE,IAC1DzB,EAAEiF,KAAKd,OAIV,OAAOnE,KAMT2B,0BAA2B,SAA0BC,GACpD,OAAO3B,EAAe0D,iBAAiBnB,KAAKpE,KAAM0E,OAAOC,QACxDmD,MAAOjD,EAAwBpB,UAAUoC,aACvCrC,KAGJK,0BAA2B,SAA0BL,GACpD,OAAO3B,EAAe6D,iBAAiBtB,KAAKpE,KAAM0E,OAAOC,QACxDmD,MAAOjG,EAAe4B,UAAUd,oBAChCC,SAAUiC,EAAwBpB,UAAUwC,gBAC1CzC,QEjHDI,EAAyBvE,EAAQuE,uBAAyBhF,EAAQO,GACrEW,YAAa,SAAgCC,GAC5CZ,EAAOiF,KAAKpE,KAAMD,GAClBC,KAAK2D,WAAa5D,EAAO4D,YAO1BoE,SAAU,SAAkB3H,EAAMK,GACjC,IAAIuH,EAAa5H,EAAKC,QAAQI,GAC7BkD,EAAa3D,KAAK2D,WAClBnD,EAAcmD,EAAWtB,SAASjC,EAAMK,GACxCwH,EAAStE,EAAW3B,UAAUzB,eAAeC,EAAaJ,EAAMK,GAIjE,OAHIuH,EAAWhC,QAAQiC,GAAU,IAChCA,EAAStE,EAAWzB,OAAOQ,OAAOsF,IAE5BC,KCnBLjE,EAAyB3E,EAAQ2E,uBAAyBpF,EAAQQ,GACrEU,YAAa,SAAgCC,GAC5CX,EAAgBgF,KAAKpE,KAAMD,GAC3BC,KAAK2D,WAAa5D,EAAO4D,YAM1BuE,mBAAoB,SAAUvE,EAAYvD,EAAMK,GAC/C,IAAIG,EAAeR,EAAKQ,eACvBuH,EAA2E,IAAjEC,KAAK9G,IAAI8G,KAAKC,IAAIzH,EAAa,IAAKwH,KAAKC,IAAIzH,EAAa,KACpEqC,EAAQU,EAAWX,mBAAmB5C,EAAMK,GAI7C,OAHU3B,EAASmE,GAAOF,IAAI,SAAUM,GACtC,OAAOA,EAAE,GAAKA,EAAE,KACdgC,MAAQ8C,GAIbpE,UAAW,SAAU3D,EAAMgB,GAC1B,OAAOpB,KAAKF,YAAYiE,UAAU/D,KAAK2D,WAAYvD,EAAMgB,MCrBvDkH,EAAY3I,EAAM2I,aCFrB,ODIDA,EAAUC,mBAAqB9J,EAAKG,QAAQiB,GAC3CC,YAAa,SAA4BC,IACxCA,EAASA,OACFK,KAAOL,EAAOK,MAAQ,IAAIzB,EAAQgB,MAAM6I,UAC/C3I,EAAUuE,KAAKpE,KAAMD,IAKtBI,cAAe,SAAuBC,GACrC,OAAQ,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAOzBqI,kBAAmBhK,EAAKM,SAASyG,QAASnE,KAAM,EAAGC,IAAK,GAAK,GAAGR,UAEhEI,cAAe,WACd,OAAOlB,KAAKyI,mBAGbxH,SAAU,SAAkBb,EAAMgB,GACjC,IAAI/B,EAAUe,EAAKf,QAAQ0D,IAAI,SAAUwB,GACvC,OAAOA,EAAEmE,OAAO,KAEjBC,EAASvH,IAAWhB,EAAKf,QAAQ,GAAK,GAAM,EAC7C,OAAOe,EAAKwI,MAAMnB,MAAK,IAAK1E,IAAI,SAAU8F,GACzC,OAAQA,IAAOxJ,EAAQ,GAAMsJ,EAAUE,IAAOxJ,EAAQ,IAAOsJ,EAAS,OAKzEL,EAAUQ,MAAQ,IAAIR,EAAUC,mBAEhCD,EAAUS,aAAelE,EAAwBmE,eAC9CC,EAAG,cACHC,UAAW,cACXC,EAAG,8DACHC,EAAG,8DACHC,EAAG,0CACHC,EAAG,0CACHC,EAAG,8DACHC,EAAG,iEAINlB,EAAUmB,sBAAwB,SAA+B7D,GAOhE,OANAA,EAAQA,GAAS0C,EAAUS,cAKb,IAJGlE,EAAwBU,kBACvCvD,UAAWsG,EAAUQ,MACrBnD,UAAWC,MAGKxE,UAGnBkH,EAAUoB,aAAe7E,EAAwBmE,eAChD7B,IAAK,oDACLE,IAAK,uDAGNiB,EAAUqB,sBAAwB,SAA+B/D,GAOhE,OANAA,EAAQA,GAAS0C,EAAUoB,cAKb,IAJG7E,EAAwBa,kBACvC1D,UAAWsG,EAAUQ,MACrBnD,UAAWC,MAGKxE,UExEnBxB,EAASgK,iDAAmD,SAA0DC,GAErH,IAAIC,GADJD,EAAaA,GAAcE,QAAO,eACTD,QAExBE,GADerL,EAAQU,QAAQ4K,aACjBtL,EAAQuL,YAAYF,aAuInC,OArIoDpL,EAAQkL,GAC3D5H,OAAQzD,EAAK0D,WAAWC,QACxB+H,YAAcjH,EAAAA,GACdkH,UAAW,GACXC,WAAY,EAEZvK,YAAa,SAAuDC,GACnEb,EAAWc,KAAMD,GACfuK,KAAI,kBACJC,QAAO,aAAgBC,QAAQ,EAAMtK,QAAQ,IAC7CqK,QAAO,cAAiBC,QAAQ,EAAMtK,QAAQ,IAC9C6B,MAAK,aAAgB7B,QAAQ,IAC/BF,KAAKyK,UAAYzK,KAAK0K,kBAAkB1K,KAAKyK,WAE7C,IAAIL,EAAYpK,KAAKoK,UACpB/F,EAAkBrE,KAAKyE,eAAehB,UAAUY,gBACzCrE,KAAKyE,eAAehB,UAAUzB,UAAU5B,KAChD0J,EAAQ1F,KAAKpE,KAAM0E,OAAOC,OAAO5E,GAChC4K,MAAO,mBAAoB3K,KAAKyE,eAChCmG,YAAa,2CAA4C5K,KAAKyE,eAC9DoG,aAAcxG,EAAgBtB,IAAI,SAAUkC,GAC3C,OAAS6F,GAAI7F,EAAM3D,IAAM2D,EAAM5D,KAAO+I,EAAY,QAIpDpK,KAAK+K,QAAQtH,UAAUuH,OAAS,WAQ/B,MAAO,aAP8B,OAApBhL,KAAKiL,WAAsB,IAC1CjL,KAAKiL,WAAWlI,IAAI,SAAUmI,GAC7B,OAAO9C,KAAK+C,MAAU,IAAJD,GAAW,MAC3BE,KAAI,MAIsB,IAHrBpL,KAAKwG,SAASzD,IAAI,SAAUO,GACpC,OAAO+H,OAAOC,aAAsB,OAAL,EAAHhI,MAC1B8H,KAAI,IACoC,KAE7CpL,KAAK+K,QAAQtH,UAAUb,SAAW,WACjC,OAAO2I,OAAOC,KAAKxL,KAAKyL,QAAQR,WAAWjL,MAAO,SAAUkL,GAQ3D,OAPIlL,KAAK0L,sBACRR,GAAKS,KAAKV,YAAcjL,KAAK0L,oBAAsB,GAAKR,GACvDlL,KAAK0L,qBAEP1L,KAAK0L,oBAAsD,GAAL,EAA1B1L,KAAK0L,qBACjCC,KAAKV,WAAaC,EAClBrM,EAA4B,OAApB8M,KAAKV,WAAqB,qBAAsBU,KAAM,aACvDA,KAAKV,eAKfW,0BAA2B,SAA4BC,GAEtD,GAAY,YADZA,EAAMA,EAAIC,eAET,OAAO,IAAInN,EAAQU,QAAQ4K,cAAe8B,KAAM,WAC1C,GAAG,YAAaC,KAAKH,GAAM,CACjC,IAAII,GAAKJ,EAAIK,OAAO,GACpB,OAAO,IAAIvN,EAAQU,QAAQ6E,iBAC1B6H,KAAM,QAAmBE,EAAE,IAC3BE,QAASF,EAAE,IAEN,GAAG,YAAaD,KAAKH,GAAM,CACjC,IAAIO,GAAKP,EAAIK,OAAO,GACpB,OAAO,IAAIvN,EAAQU,QAAQgN,kBAC1BN,KAAM,QAASK,EAAE,IACjBE,gBAAiBF,EACjBG,QAAUrJ,EAAAA,IAGXsJ,MAAK,qBAAuBX,EAAI,OAIlCnB,kBAAmB,SAA2BD,GAC7C,IAAInD,EAAOtH,KACX,OAAOyK,EAAU1H,IAAI,SAAU0J,EAAUjI,GAMxC,MALwB,iBAAbiI,IACVA,EAAWnF,EAAKoF,mBAAmBD,IAEpC5N,IAAS4N,GAAcA,aAAoB9N,EAAQQ,QAClD,4BAA6BqF,EAAG,KAC1BiI,KAIThC,WAAW,UAEXkC,QAAS,SAAiBC,GACzB,IAAIxC,EAAYpK,KAAKoK,UACpB/F,EAAkBrE,KAAKyE,eAAehB,UAAUY,gBAChDtE,EAAShB,EAAS0C,IAAImL,EAAQpG,SAAUnC,GACvC3C,SAAS,SAAU4B,EAAG1B,GACtB,OAAOwG,KAAK9G,IAAIM,EAAEP,IAAK+G,KAAK/G,IAAIO,EAAEN,IACjCgC,EAAI8G,GAAaxI,EAAEN,IAAMM,EAAEP,KAAOO,EAAEP,QACnCP,UACJ,OAAO,IAAId,KAAKyE,gBAAiBH,WAAYvE,KAG9CqB,OAAQ,SAAgBuC,GACvB,OAAOA,EAAWvC,QAAS2K,KAAM,aAGlCd,WAAY,SAAoB2B,GAC/B,IAAIxM,EAAOJ,KAAKyE,eAAehB,UAAUzB,UAAU5B,KAClDuD,EAAa3D,KAAK2M,QAAQC,GAC1BxL,EAASpB,KAAKoB,OAAOuC,GACrBkJ,EAAa,IAAI7C,EAAY5J,GAAOgB,GAASpB,KAAKyK,UAAWzK,KAAKqK,YACnE,OAAOwC,EAAWC,MAAMtB,KAAK,WAC5B,IAAIuB,EAAQF,EAAWG,WACvB,QAAUD,EAAM5J,OAAQ8J,IAAK,YAAa7L,OAAQA,EAAO2K,OACxDgB,EAAM5J,OAAQ8J,IAAK,UAAW7L,OAAQA,EAAO2K,QAC7CgB,EAAM5J,OAAQ8J,IAAK,UAAW7L,OAAQA,EAAO2K,WAIhDnJ,SAAU,SAAkBsK,GAC3B,OAAOpD,EAAQrG,UAAUb,SAASwB,KAAKpE,KAAMkN,GAAU,IAGxDC,iBAAkB,SAA0BpN,GAC3C,IAAIqN,EAAK,IAAIvD,EAAWwD,eAAeC,iBAAiB5I,OAAOC,QAC9D8G,QAASzL,KACTuN,aAAc,IACdC,KAAM,GACNC,MAAO,IACL1N,IAMH,OALAqN,EAAGM,OAAOC,GAAE,WAAa,SAAUP,GAClC,KAAOA,EAAGQ,MAAMnL,OAAS2K,EAAGI,MAC3BJ,EAAGQ,MAAM/G,KAAK,IAAIuG,EAAG3B,QAAQV,WAGxBqC,MDzIF9N","file":"ludorum-player-ml.min.js","sourcesContent":["/** Library ludorum-classifier-player wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum){ \"use strict\";\n\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\traiseIf = base.raiseIf,\n\t\titerable = base.iterable,\n\t\tIterable = base.Iterable,\n\t\tunimplemented = base.objects.unimplemented,\n\t\tinitialize = base.initialize,\n\n\t\tPlayer = ludorum.Player,\n\t\tHeuristicPlayer = ludorum.players.HeuristicPlayer;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t\t__package__: 'ludorum-player-ml',\n\t\t\t__name__: 'ludorum_player_ml',\n\t\t\t__init__: __init__,\n\t\t\t__dependencies__: [base, Sermat, ludorum]\n\t\t},\n\t\tclassifiers = exports.classifiers = { },\n\t\tplayers = exports.players = { },\n\t\tgames = exports.games = { },\n\t\ttraining = exports.training = { };\n\n// See __epilogue__.js\n","\n/** # Game model\n\nA game model provides the necessary metadata to process the state of a game with a classifier.\n*/\nvar GameModel = exports.GameModel = declare({\n\tconstructor: function GameModel(params) {\n\t\tinitialize(this, params)\n\t\t/** TODO\n\t\t*/\n\t\t\t.object('game', { ignore: true })\n\t\t;\n\t},\n\n\t/** Classifiers that use the game's actions as classes must know the set of all possible\n\tactions that any player can make in any possible game state. By default, all the actions for\n\tthe active player of the given game instance is used. \n\t*/\n\tactionClasses: function actionClasses(game) {\n\t\tgame = game || this.game;\n\t\treturn game.moves()[game.activePlayer()];\n\t},\n\n\tactionForClass: function actionForClass(actionClass, game, role) {\n\t\treturn actionClass;\n\t},\n\n\t/** Classifiers that use the game's results as classes must know the set of all posible results\n\tthat any possible match can end with for all players. By default, the bounds for the game \n\tresults and zero are used.\n\t*/\n\tresultClasses: function resultClasses(game) {\n\t\tgame = game || this.game;\n\t\treturn base.Iterable.chain([0], game.resultBounds()).sorted().toArray();\n\t},\n\n\tresultForClass: function resultForClass(resultClass, game, role) {\n\t\treturn resultClass;\n\t},\n\n\t/** Classifiers take as inputs a set of features that describe every possible game state. Every\n\tfeature is a number, within a given range. In order to execute a classifier, the list of\n\t`features` must be calculated from a given `game` state. Usually these values also change\n\tdepending on the perspective of the `player`.\n\t*/\n\tfeatures: unimplemented('GameModel', 'feature(game, player)'),\n\n\t/** In order to properly build a classifier, the amount of features and their possible values\n\t(i.e. their ranges) must be known.\n\t*/\n\tfeatureRanges: unimplemented('GameModel', 'featureRanges(game)'),\n\n\t// ## Utilities ###############################################################################\n\n\t/** Some classifiers use the features as they are calculated. Others may need to normalize\n\tthese values. By default features are normalized in the [0, 1] range.\n\t*/\n\tnormalizedFeatures: function normalizedFeatures(game, player, min, max) {\n\t\tmin = isNaN(min) ? 0 : +min;\n\t\tmax = isNaN(max) ? 1 : +max;\n\t\tvar d = max - min;\n\t\treturn Iterable.zip(this.features(game, player), this.featureRanges())\n\t\t\t.mapApply(function (f, r) {\n\t\t\t\treturn (f - r.min) / (r.max - r.min) * d + min;\n\t\t\t}).toArray();\n\t}\n}); // declare GameModel","/** # Game classifier\n\nA game classifier is a classifier that takes its inputs from a game state and a player. The outputs\n(classes) can be different concepts, depending on the way the classifier is meant to be used.\n*/\nvar GameClassifier = exports.GameClassifier = declare({\n\t/** The base `GameClassifier` type is not meant to be used, but rather to be extended. The base\n\tconstructor may take the following arguments:\n\t*/\n\tconstructor: function GameClassifier(args) {\n\t\tinitialize(this, args)\n\t\t/** + `gameModel`: the game model that defines features and classes for the games to be \n\t\t\tclassified. \n\t\t*/\n\t\t\t.object('gameModel', { ignore: true })\n\t\t/** + `classes` is a list of values, each belonging to one of the classes in which the \n\t\t\tgame states are supposed to be classified.\n\t\t*/\n\t\t\t.array('classes', { ignore: true })\n\t\t/** + `random`: a pseudo-random number generator, as a `base.Randomness` instance.\n\t\t*/\n\t\t\t.object('random', { ignore: true })\n\t\t;\n\t},\n\n\t/** The `gameModel` is used to calculate features and other information from game states.\n\t*/\n\tgameModel: null,\n\n\t/** No classes are defined by default. */\n\tclasses: [],\n\n\t/** The default value for `random` is the default is the default `base.Randomness` singleton.\n\tThis is not seeded. It is adviced to change this when performing simulations or training.\n\t*/\n\trandom: base.Randomness.DEFAULT,\n\n\t// ## Classification ##########################################################################\n\n\t/** The base implementation returns a class at random. Only useful for testing purposes.\n\t*/\n\tclassify: function classify(game, player) {\n\t\treturn this.classify_randomMatch(game, player);\n\t},\n\n\t/** Simple classification that returns the first class that matches the `game` state.\n\t*/\n\tclassify_firstMatch: function classify_firstMatch(game, player) {\n\t\tvar matches = this.matches(game, player);\n\t\treturn matches.length > 0 ? matches[0] : null;\n\t},\n\n\tclassify_randomMatch: function classify_randomMatch(game, player) {\n\t\tvar matches = this.matches(game, player);\n\t\treturn matches.length > 0 ? this.random.choice(matches) : null;\n\t},\n\n\t// ## Matching ################################################################################\n\n\t/** Although the function of a classifier is to choose one and only one class for a given game\n\tstate, sometimes it may be useful to know whether many classes can apply. The `matches` method\n\treturns a list of classes that may apply to the given `game` state. By default it returns all\n\tpossible classes.\n\t*/\n\tmatches: function matches(game, player) {\n\t\treturn this.classes;\n\t},\n\n\t/** If the `evaluate` method is implemented, the `match_bestEvaluated` method returns an array\n\twith the best evaluated classes.\n\t*/\n\tmatch_bestEvaluated: function match_bestEvaluated(game, player) {\n\t\tvar classes = this.classes;\n\t\treturn iterable(this.evaluate(game, player)).greater(function (clazz) {\n\t\t\treturn clazz[1];\n\t\t}).map(function (clazz) {\n\t\t\treturn classes[clazz[0]];\n\t\t});\n\t},\n\n\t// ## Evaluation ##############################################################################\n\n\t/** To `evaluate` a classifier is to calculate a list of pairs `[class, n]`, where `n` is a\n\tnumerical evaluation of the membership of the given `game` state to the corresponding `class`.\n\tThe greater the evaluation, the most likely the game state is to belong to the class.\n\t*/\n\tevaluate: function evaluate(game, player) {\n\t\tvar random = this.random;\n\t\treturn this.classes.map(function (clazz) {\n\t\t\treturn [clazz, random.random()];\n\t\t});\n\t},\n\n\t/** The normalization makes the evaluations for all classes fit in the [0,1] range.\n\t*/\n\tnormalizedEvaluate: function normalizedEvaluate(game, player) {\n\t\tvar evals = iterable(this.evaluate(game, player)),\n\t\t\tmin = +Infinity,\n\t\t\tmax = -Infinity,\n\t\t\tcount = 0;\n\t\tevals.forEachApply(function (c, v) {\n\t\t\tif (min > v) {\n\t\t\t\tmin = v;\n\t\t\t}\n\t\t\tif (max < v) {\n\t\t\t\tmax = v;\n\t\t\t}\n\t\t\tcount++;\n\t\t});\n\t\tvar d = max - min;\n\t\treturn evals.mapApply(function (c, v) {\n\t\t\treturn [c, (v - min) / (d || max || 1) / count];\n\t\t}).toArray();\n\t},\n\n\t// ## Players #################################################################################\n\n\t/** An `actionClassifier` is a game classifier that uses the game's possible actions as the\n\tclasses into which classify any game state.\n\t*/\n\t'static actionClassifier': function actionClassifier(members) {\n\t\tvar gameModel = members.gameModel || this.prototype.gameModel;\n\t\traiseIf(!gameModel, 'Game model not provided!');\n\t\tmembers = base.copy({}, members, {\n\t\t\t\tclasses: gameModel.actionClasses(),\n\t\t\t\t\n\t\t\t\t/** The player used by an action classifier is `ActionClassifierPlayer` by default.\n\t\t\t\t*/\n\t\t\t\tplayer: function player(params) {\n\t\t\t\t\tparams = base.copy({}, params, { classifier: this });\n\t\t\t\t\treturn new ActionClassifierPlayer(params);\n\t\t\t\t}\n\t\t\t});\n\t\treturn declare(this, members);\n\t},\n\n\t/** An `resultClassifier` is a game classifier that uses the game's possible results as the\n\tclasses into which classify any game state.\n\t*/\n\t'static resultClassifier': function resultClassifier(members) {\n\t\tvar gameModel = members.gameModel || this.prototype.gameModel;\n\t\traiseIf(!gameModel, 'Game model not provided!');\n\t\tmembers = base.copy({}, members, {\n\t\t\t\tclasses: gameModel.resultClasses(),\n\t\t\t\t\n\t\t\t\t/** The player used by an action classifier is `ActionClassifierPlayer` by default.\n\t\t\t\t*/\n\t\t\t\tplayer: function player(params) {\n\t\t\t\t\tparams = base.copy({}, params, { classifier: this });\n\t\t\t\t\tif (params.hasOwnProperty('horizon')) {\n\t\t\t\t\t\tparams.heuristic = ResultClassifierPlayer.heuristic.bind(null, this);\n\t\t\t\t\t\treturn new ludorum.players.AlphaBetaPlayer(params);\n\t\t\t\t\t}\n\t\t\t\t\treturn new ResultClassifierPlayer(params);\n\t\t\t\t}\n\t\t\t});\n\t\treturn declare(this, members);\n\t},\n\n}); // declare GameClassifier\n","/** # Parametrical classifiers\n\nGame classifiers defined by a list of parameters.\n*/\nvar ParametricalGameClassifier = classifiers.ParametricalGameClassifier = declare(GameClassifier, {\n\t/** All classifiers are defined by a list of numerical `parameters`.\n\t*/\n\tconstructor: function ParametricalGameClassifier(args) {\n\t\tGameClassifier.call(this, args);\n\t\tvar parameterRanges = this.parameterRanges,\n\t\t\tparameters = args.parameters || [];\n\t\traiseIf(parameters.length !== parameterRanges.length, \n\t\t\t\"Expected \", parameterRanges.length, \" parameters, but got \", parameters.length, \"!\");\n\t\tIterable.zip(parameters, parameterRanges).forEachApply(function (p, r, i) {\n\t\t\traiseIf(p < r.min || p > r.max, \"Value \", p, \" for parameter \", i, \" not in range [\",\n\t\t\t\tr.min, \",\", r.max, \"]!\");\n\t\t});\n\t\tthis.parameters = parameters;\n\t},\n\n\t/** The class property `parameterRanges` is a list of ranges (e.g. `{min:0, max:1}`) for the \n\tparameters required to build a classifier of this type.\n\t*/\n\tparameterRanges: [],\n\n\t/** Parametrical classifiers pick the class with greater evaluation. If more than one has the \n\tgreatest evaluation, one of these is chosen at random.\n\t*/\n\tmatches: GameClassifier.prototype.match_bestEvaluated,\n\n\t/** An `actionClassifier` is a game classifier that uses the game's possible actions as the\n\tclasses into which classify any game state.\n\t*/\n\t'static actionClassifier': function actionClassifier(ClassifierType, gameModel, parameterRanges) {\n\t\traiseIf(typeof ClassifierType !== 'function', \"Invalid ClassifierType!\");\n\t\traiseIf(!parameterRanges, \"Invalid parameterRanges!\");\n\t\treturn declare(ClassifierType, {\n\t\t\tgameModel: gameModel,\n\t\t\tclasses: gameModel.actionClasses(),\n\t\t\tparameterRanges: parameterRanges,\n\n\t\t\t/** The player used by an action classifier is `ActionClassifierPlayer` by default.\n\t\t\t*/\n\t\t\tplayer: function player(params) {\n\t\t\t\treturn new ActionClassifierPlayer(Object.assign(params || {}, {\n\t\t\t\t\tclassifier: this\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t},\n\n\t/** An `resultClassifier` is a game classifier that uses the game's possible results as the\n\tclasses into which classify any game state.\n\t*/\n\t'static resultClassifier': function resultClassifier(ClassifierType, gameModel, parameterRanges, resultClasses) {\n\t\traiseIf(typeof ClassifierType !== 'function', \"Invalid ClassifierType!\");\n\t\traiseIf(!parameterRanges, \"Invalid parameterRanges!\");\n\t\treturn declare(ClassifierType, {\n\t\t\tgameModel: gameModel,\n\t\t\tclasses: resultClasses || gameModel.resultClasses(),\n\t\t\tparameterRanges: parameterRanges,\n\n\t\t\t/** If an `horizon` parameter is given, the player used by the classifier is an\n\t\t\t`AlphaBetaPlayer` with an heuristic that uses the classifier. Else the\n\t\t\t`ResultClassifierPlayer` is used.\n\t\t\t*/\n\t\t\tplayer: function player(params) {\n\t\t\t\tparams = Object.assign(params || {}, {\n\t\t\t\t\tclassifier: this\n\t\t\t\t});\n\t\t\t\tif (params.hasOwnProperty('horizon')) {\n\t\t\t\t\tparams.heuristic = ResultClassifierPlayer.heuristic.bind(null, this);\n\t\t\t\t\treturn new ludorum.players.AlphaBetaPlayer(params);\n\t\t\t\t}\n\t\t\t\treturn new ResultClassifierPlayer(params);\n\t\t\t}\n\t\t});\n\t},\n\n\t/** `randomClassifier` builds a classifier of this type with random parameters.\n\t*/\n\t'static randomClassifier': function randomClassifier(random) {\n\t\trandom = random || this.prototype.random;\n\t\tvar parameterRanges = this.prototype.parameterRanges;\n\t\traiseIf(!parameterRanges, \"Parameter ranges are not defined!\");\n\t\tvar params = parameterRanges.map(function (r) {\n\t\t\treturn random.random(r.min, r.max);\n\t\t});\n\t\treturn new this({ parameters: params });\n\t}\n}); // declare ParametricalGameClassifier\n","/** # Rule based game classifier\n\nA rule based game classifier selects a class for a game state based on a list of rules. Rules that \napply indicate a class. If many rules apply, different classifications must be resolved.\n*/\nvar RuleBasedGameClassifier = classifiers.RuleBasedGameClassifier = declare(GameClassifier, {\n\tconstructor: function RuleBasedGameClassifier(args) {\n\t\tGameClassifier.call(this, args);\n\t\tthis.__rules__ = args && args.rules || [];\n\t},\n\n\t/** The `rules` property is a list of lists of functions with the signature \n\t`(features, game, role)` returning a class if the rule applies or `null` if it does not. Each \n\tfunction is called a _rule_, and a list of rules is a called a _level_.\n\t*/\n\trules: function rules() {\n\t\treturn this.__rules__;\n\t},\n\n\t__rules__: [],\n\n\tclassify: GameClassifier.prototype.classify_firstMatch,\n\n\t/** Matching goes level by level, and stops at the first level that has at least one rule that\n\tapplies to the given game state.\n\t*/\n\tmatch_rules: function match_rules(game, role, rules, ruleContext) {\n\t\trules = rules || this.rules();\n\t\tvar features = this.gameModel.features(game, role),\n\t\t\tclasses = this.classes,\n\t\t\tmatches = [];\n\t\tfor (var i = 0; matches.length < 1 && i < rules.length; i++) {\n\t\t\tmatches = iterable(rules[i]).map(function (rule) {\n\t\t\t\treturn rule.call(ruleContext, features, game, role);\n\t\t\t}, function (clazz) {\n\t\t\t\treturn classes.indexOf(r) >= 0;\n\t\t\t}).toArray();\n\t\t}\n\t\treturn matches;\n\t},\n\n\t/**\n\t*/\n\tevaluate_rules: function evaluate_rules(game, role, rules, ruleContext) {\n\t\trules = rules || this.rules();\n\t\tvar features = this.gameModel.features(game, role),\n\t\t\tcounts = Iterable.zip(this.classes, Iterable.repeat(0)).toObject(),\n\t\t\tdone = false,\n\t\t\tlevel;\n\t\tfor (var i = 0; !done && i < rules.length; i++) {\n\t\t\trules[i].forEach(function (level) {\n\t\t\t\tvar c = rule.call(ruleContext, features, game, role);\n\t\t\t\tif (typeof c !== 'undefined' && c !== null) {\n\t\t\t\t\tcounts[c]++;\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn iterable(counts).toArray();\n\t},\n\n\t// ## Rule construction #######################################################################\n\n\t'dual ruleFromValues': function ruleFromValues(values, clazz, metadata) {\n\t\tvar ruleFunction = function (features) {\n\t\t\tvar result = Iterable.zip(features, values).all(function (p) {\n\t\t\t\t\tvar f = p[0], v = p[1];\n\t\t\t\t\treturn (typeof v === 'undefined' || v === null || f === v);\n\t\t\t\t}) ? clazz : null;\n\t\t\treturn result;\n\t\t};\n\t\tObject.assign(ruleFunction, metadata);\n\t\treturn ruleFunction;\n\t},\n\n\tadd_ruleFromValues: function add_ruleFromValues(values, clazz, metadata) {\n\t\tthis.__rules__.push(this.ruleFromValues(values, clazz, metadata));\n\t\treturn this;\n\t},\n\n\t'dual parseActions': function parseActions(levels, chars2Features) {\n\t\tchars2Features = chars2Features || {\n\t\t\t'.': null,\n\t\t\t'+': +1, '_':  0, '-': -1\n\t\t};\n\t\tvar self = this;\n\t\n\t\treturn levels.map(function (level) {\n\t\t\tvar r = [],\n\t\t\t\tvs;\n\t\t\tfor (var k in level) {\n\t\t\t\tvs = level[k];\n\t\t\t\tk.split('|').forEach(function (clazz) {\n\t\t\t\t\tvs.split(/\\s+/).forEach(function (chars) {\n\t\t\t\t\t\tvar fs = chars.split('').map(function (chr) {\n\t\t\t\t\t\t\t\treturn chars2Features[chr];\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tc = +(clazz === '+' ? +1 : clazz === '-' ? -1 : clazz),\n\t\t\t\t\t\t\trule = self.ruleFromValues(fs, c, { features: fs, class: c });\n\t\t\t\t\t\tr.push(rule); \n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn r;\n\t\t});\n\t},\n\n\t// ## Players #################################################################################\n\n\t'static actionClassifier': function actionClassifier(members) {\n\t\treturn GameClassifier.actionClassifier.call(this, Object.assign({\n\t\t\tmatch: RuleBasedGameClassifier.prototype.match_rules \n\t\t}, members));\n\t},\n\n\t'static resultClassifier': function resultClassifier(members) {\n\t\treturn GameClassifier.resultClassifier.call(this, Object.assign({\n\t\t\tmatch: GameClassifier.prototype.match_bestEvaluated,\n\t\t\tevaluate: RuleBasedGameClassifier.prototype.evaluate_rules \n\t\t}, members));\n\t},\n\n}); // declare RuleBasedGameClassifier","/** # Linear classifier\n\nA [linear classifier](https://en.wikipedia.org/wiki/Linear_classifier) selects a class for an\ngame state based on a linear combination of its features.\n*/\nvar LinearGameClassifier = classifiers.LinearGameClassifier = declare(ParametricalGameClassifier, {\n\tconstructor: function LinearGameClassifier(args) {\n\t\tParametricalGameClassifier.call(this, args);\n\t\tvar parameters = args && args.parameters,\n\t\t\tfeatureCount = this.gameModel.featureRanges().length;\n\t\tthis.__parameters__ = Iterable.range(this.classes.length).map(function (i) {\n\t\t\treturn parameters.slice(i * featureCount, (i + 1) * featureCount);\n\t\t}).toArray();\n\t},\n\n\t/** Every class has a vector with a weight for every feature. A linear classifier is evaluated\n\tby calculating the product of this weight vector and the feature vector for every class.\n\t*/\n\tevaluate: function evaluate(game, player) {\n\t\tvar features = this.gameModel.normalizedFeatures(game, player);\n\t\treturn iterable(this.__parameters__).map(function (params, i) {\n\t\t\t\tvar r = Iterable.zip(params, features).mapApply(function (w, x) {\n\t\t\t\t\treturn w * x;\n\t\t\t\t}).sum();\n\t\t\t\treturn [i, r];\n\t\t\t}).toArray();\n\t},\n\n\t/** An action classifier based on a linear classifier has as many parameters as the product of\n\tthe feature count by the class count, i.e. the amount of possible actions in the game model.\n\t*/\n\t'static actionClassifier': function actionClassifier(gameModel) {\n\t\tvar featureCount = gameModel.featureRanges().length,\n\t\t\tclasses = gameModel.actionClasses(),\n\t\t\tparamCount = featureCount * classes.length;\n\t\treturn ParametricalGameClassifier.actionClassifier(this, gameModel,\n\t\t\tIterable.repeat({ min: -1, max: +1 }, paramCount).toArray()\n\t\t);\n\t},\n\n\t/** A result classifier based on a linear classifier has as many parameters as the product of\n\tthe feature count by the class count, i.e. the amount of possible results in the game model.\n\t*/\n\t'static resultClassifier': function resultClassifier(gameModel, possibleResults) {\n\t\tvar featureCount = gameModel.featureRanges().length,\n\t\t\tclasses = possibleResults || gameModel.resultClasses(),\n\t\t\tparamCount = featureCount * classes.length;\n\t\treturn ParametricalGameClassifier.resultClassifier(this, gameModel,\n\t\t\tIterable.repeat({ min: -1, max: +1 }, paramCount).toArray(),\n\t\t\tpossibleResults);\n\t}\n}); // declare LinearGameClassifier\n","/** # Action classifier player\n\n`ActionClassifierPlayer`s are simple players that use the given classifier to directly choose the\naction to make. The game `classifier` must be set up to use the game's possible actions as the\nclasses into which classify any game state.\n*/\nvar ActionClassifierPlayer = players.ActionClassifierPlayer = declare(Player, {\n\tconstructor: function ActionClassifierPlayer(params) {\n\t\tPlayer.call(this, params);\n\t\tthis.classifier = params.classifier;\n\t},\n\n\t/** To make a `decision`, the given `game` state is evaluated by the player's `classifier`. All\n\tnon-viable actions are removed. The best evaluated viable actions is selected. If more than one\n\thas the best score, one of the best evaluated is selected randomly.\n\t*/\n\tdecision: function decision(game, role) {\n\t\tvar validMoves = game.moves()[role],\n\t\t\tclassifier = this.classifier,\n\t\t\tactionClass = classifier.classify(game, role),\n\t\t\taction = classifier.gameModel.actionForClass(actionClass, game, role);\n\t\tif (validMoves.indexOf(action) < 0) {\n\t\t\taction = classifier.random.choice(validMoves);\n\t\t}\n\t\treturn action;\n\t}\n}); // declare ActionClassifierPlayer","/** # Result classifier player\n\n`ResultClassifierPlayer`s are simple players that use the given classifier as a heuristic evaluation\nof game states.\n*/\nvar ResultClassifierPlayer = players.ResultClassifierPlayer = declare(HeuristicPlayer, {\n\tconstructor: function ResultClassifierPlayer(params) {\n\t\tHeuristicPlayer.call(this, params);\n\t\tthis.classifier = params.classifier;\n\t},\n\n\t/** Heuristic functions based on result classifiers return a normalized weighted average of the\n\tclassifier's evaluation. Each class is assumed to have a numerical value.\n\t*/\n\t'static heuristic': function (classifier, game, role) {\n\t\tvar resultBounds = game.resultBounds(),\n\t\t\tdivisor = Math.max(Math.abs(resultBounds[0]), Math.abs(resultBounds[1])) * 1.1,\n\t\t\tevals = classifier.normalizedEvaluate(game, role),\n\t\t\tresult = iterable(evals).map(function (c) {\n\t\t\t\treturn c[0] * c[1];\n\t\t\t}).sum() / divisor;\n\t\treturn result;\n\t},\n\n\theuristic: function (game, player) {\n\t\treturn this.constructor.heuristic(this.classifier, game, player);\n\t}\n}); // declare ResultClassifierPlayer\n","/** # TicTacToe model.\n\nExample of a game model for TicTacToe.\n*/\nvar tictactoe = games.tictactoe = {};\n\ntictactoe.TicTacToeGameModel = base.declare(GameModel, {\n\tconstructor: function TicTacToeGameModel(params) {\n\t\tparams = params || {};\n\t\tparams.game = params.game || new ludorum.games.TicTacToe();\n\t\tGameModel.call(this, params);\n\t},\n\n\t/** The action classes for TicTacToe map to all possible moves.\n\t*/\n\tactionClasses: function actionClasses(game) {\n\t\treturn [0,1,2,3,4,5,6,7,8];\n\t},\n\n\t/** A TicTacToe game has 9 features, one for each square in the board. An empty square has a\n\tvalue of zero. A square marked by the opponent has a value of -1. Squares marked by the player\n\thave a value of +1.\n\t*/\n\t__featureRanges__: base.Iterable.repeat({ min: -1, max: 1 }, 9).toArray(),\n\n\tfeatureRanges: function featureRanges() {\n\t\treturn this.__featureRanges__;\n\t},\n\n\tfeatures: function features(game, player) {\n\t\tvar players = game.players.map(function (p) {\n\t\t\t\treturn p.charAt(0);\n\t\t\t}),\n\t\t\tfactor = player === game.players[0] ? +1 : -1;\n\t\treturn game.board.split('').map(function (sq) {\n\t\t\treturn (sq === players[0]) ? factor : (sq === players[1]) ? -factor : 0;\n\t\t});\n\t}\n}); // declare TicTacToeGameModel\n\ntictactoe.MODEL = new tictactoe.TicTacToeGameModel();\n\ntictactoe.ACTION_RULES = RuleBasedGameClassifier.parseActions([\n\t{ 4: '...._....' },\n\t{ '0|2|6|8': '....-....' },\n\t{ 0: '_--...... _++...... _..-..-.. _..+..+.. _...-...- _...+...+',\n\t  2: '--_...... ++_...... .._..-..- .._..+..+ .._.-.-.. .._.+.+..',\n\t  3: '..._--... ..._++... -.._..-.. +.._..+..',\n\t  5: '...--_... ...++_... ..-.._..- ..+.._..+',\n\t  6: '......_-- ......_++ -..-.._.. +..+.._.. ..-.-._.. ..+.+._..',\n\t  8: '......--_ ......++_ ..-..-.._ ..+..+.._ -...-..._ +...+..._'\n\t}\n]);\n\ntictactoe.ruleBasedActionPlayer = function ruleBasedActionPlayer(rules) {\n\trules = rules || tictactoe.ACTION_RULES;\n\tvar ActionRBGC = RuleBasedGameClassifier.actionClassifier({\n\t\t\tgameModel: tictactoe.MODEL,\n\t\t\t__rules__: rules\n\t\t}),\n\t\tactionRBGC = new ActionRBGC();\n\treturn actionRBGC.player();\n};\n\ntictactoe.RESULT_RULES = RuleBasedGameClassifier.parseActions([{\n\t'+': '....+.... +........ ..+...... ......+.. ........+',\n\t'-': '....-.... -........ ..-...... ......-.. ........-'\n}]);\n\ntictactoe.ruleBasedResultPlayer = function ruleBasedResultPlayer(rules) {\n\trules = rules || tictactoe.RESULT_RULES;\n\tvar ResultRBGC = RuleBasedGameClassifier.resultClassifier({\n\t\t\tgameModel: tictactoe.MODEL,\n\t\t\t__rules__: rules\n\t\t}),\n\t\tresultRBGC = new ResultRBGC();\n\treturn resultRBGC.player();\n};","// See __prologue__.js\n\n\treturn exports;\n}","/** # Parametrical game classifier optimization problem\n\nPlayer model adjustment using the Inveniemus framework.\n*/\ntraining.getParametricalGameClassifierOptimizationProblem = function getParametricalGameClassifierOptimizationProblem(inveniemus) {\n\tinveniemus = inveniemus || require('inveniemus');\n\tvar Problem = inveniemus.Problem,\n\t\tRandomPlayer = ludorum.players.RandomPlayer,\n\t\tMeasurement = ludorum.tournaments.Measurement;\n\n\tvar ParametricalGameClassifierOptimizationProblem = declare(Problem, {\n\t\trandom: base.Randomness.DEFAULT,\n\t\tobjectives: [+Infinity],\n\t\tprecision: 10,\n\t\tmatchCount: 3,\n\n\t\tconstructor: function ParametricalGameClassifierOptimizationProblem(params) {\n\t\t\tinitialize(this, params)\n\t\t\t\t.func('ClassifierType')\n\t\t\t\t.integer('precision', { coerce: true, ignore: true })\n\t\t\t\t.integer('matchCount', { coerce: true, ignore: true })\n\t\t\t\t.array('opponents', { ignore: true });\n\t\t\tthis.opponents = this.__initOpponents__(this.opponents);\n\n\t\t\tvar precision = this.precision,\n\t\t\t\tparameterRanges = this.ClassifierType.prototype.parameterRanges,\n\t\t\t\tgame = this.ClassifierType.prototype.gameModel.game;\n\t\t\tProblem.call(this, Object.assign(params, {\n\t\t\t\ttitle: \"Optimization of \"+ this.ClassifierType,\n\t\t\t\tdescription: \"Training method based on inveniemus for \"+ this.ClassifierType,\n\t\t\t\telementModel: parameterRanges.map(function (range) {\n\t\t\t\t\treturn { n: (range.max - range.min) * precision + 1 };\n\t\t\t\t})\n\t\t\t}));\n\n\t\t\tthis.Element.prototype.emblem = function emblem() { //FIXME\n\t\t\t\tvar evaluation = this.evaluation === null ? '?' :\n\t\t\t\t\t\tthis.evaluation.map(function (e) {\n\t\t\t\t\t\t\treturn Math.round(e * 1e4) / 1e4;\n\t\t\t\t\t\t}).join(','),\n\t\t\t\t\tvalues = this.values().map(function (v) {\n\t\t\t\t\t\treturn String.fromCharCode((v |0) + 0x4DC0);\n\t\t\t\t\t}).join('');\n\t\t\t\treturn '[Element '+ evaluation +' '+ values +']';\n\t\t\t};\n\t\t\tthis.Element.prototype.evaluate = function evaluate() {\n\t\t\t\treturn Future.then(this.problem.evaluation(this), function (e) {\n\t\t\t\t\tif (this.__evaluationCount__) {\n\t\t\t\t\t\te = (elem.evaluation * (this.__evaluationCount__ - 1) + e) /\n\t\t\t\t\t\t\tthis.__evaluationCount__;\n\t\t\t\t\t}\n\t\t\t\t\tthis.__evaluationCount__ = (this.__evaluationCount__ |0) + 1;\n\t\t\t\t\telem.evaluation = e;\n\t\t\t\t\traiseIf(elem.evaluation === null, 'The evaluation of ', elem, ' is null!');\n\t\t\t\t\treturn elem.evaluation;\n\t\t\t\t});\n\t\t\t};\n\t\t},\n\n\t\t'dual opponentFromString': function opponentFromString(str) {\n\t\t\tstr = str.toLowerCase();\n\t\t\tif (str === 'random') {\n\t\t\t\treturn new ludorum.players.RandomPlayer({ name: 'Random' });\n\t\t\t} else if (/^mmab\\d+$/.test(str)) {\n\t\t\t\tvar h = +str.substr(4);\n\t\t\t\treturn new ludorum.players.AlphaBetaPlayer({\n\t\t\t\t\tname: 'MM\\u03B1\\u03B2('+ h +')',\n\t\t\t\t\thorizon: h-1\n\t\t\t\t});\n\t\t\t} else if (/^mcts\\d+$/.test(str)) {\n\t\t\t\tvar s = +str.substr(4);\n\t\t\t\treturn new ludorum.players.MonteCarloPlayer({\n\t\t\t\t\tname: 'MCTS('+ s +')',\n\t\t\t\t\tsimulationCount: s,\n\t\t\t\t\ttimeCap: +Infinity\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\traise(\"Unknown opponent '\"+ str +\"'!\");\n\t\t\t}\n\t\t},\n\n\t\t__initOpponents__: function __initOpponents__(opponents) {\n\t\t\tvar self = this;\n\t\t\treturn opponents.map(function (opponent, i) {\n\t\t\t\tif (typeof opponent === 'string') {\n\t\t\t\t\topponent = self.opponentFromString(opponent);\n\t\t\t\t}\n\t\t\t\traiseIf(!opponent || !(opponent instanceof ludorum.Player),\n\t\t\t\t\t\"Invalid opponent player #\", i, \"!\");\n\t\t\t\treturn opponent;\n\t\t\t});\n\t\t},\n\n\t\topponents: ['random'],\n\n\t\tmapping: function mapping(element) {\n\t\t\tvar precision = this.precision,\n\t\t\t\tparameterRanges = this.ClassifierType.prototype.parameterRanges,\n\t\t\t\tparams = Iterable.zip(element.values(), parameterRanges)\n\t\t\t\t.mapApply(function (v, r) {\n\t\t\t\t\treturn Math.max(r.min, Math.min(r.max,\n\t\t\t\t\t\tv / precision * (r.max - r.min) + r.min));\n\t\t\t\t}).toArray();\n\t\t\treturn new this.ClassifierType({ parameters: params });\n\t\t},\n\n\t\tplayer: function player(classifier) {\n\t\t\treturn classifier.player({ name: 'Trainee' });\n\t\t},\n\n\t\tevaluation: function evaluation(element) {\n\t\t\tvar game = this.ClassifierType.prototype.gameModel.game,\n\t\t\t\tclassifier = this.mapping(element),\n\t\t\t\tplayer = this.player(classifier),\n\t\t\t\ttournament = new Measurement(game, [player], this.opponents, this.matchCount);\n\t\t\treturn tournament.run().then(function () {\n\t\t\t\tvar stats = tournament.statistics;\n\t\t\t\treturn [ (stats.count({ key: 'victories', player: player.name }) -\n\t\t\t\t\tstats.count({ key: 'defeats', player: player.name })) /\n\t\t\t\t\tstats.count({ key: 'results', player: player.name }) ];\n\t\t\t});\n\t\t},\n\n\t\tevaluate: function evaluate(elements) {\n\t\t\treturn Problem.prototype.evaluate.call(this, elements, true); // Reevaluate.\n\t\t},\n\n\t\tgeneticAlgorithm: function geneticAlgorithm(params) {\n\t\t\tvar mh = new inveniemus.metaheuristics.GeneticAlgorithm(Object.assign({\n\t\t\t\tproblem: this,\n\t\t\t\tmutationRate: 0.25,\n\t\t\t\tsize: 10,\n\t\t\t\tsteps: 10\n\t\t\t}, params));\n\t\t\tmh.events.on('advanced', function (mh) { // Eliminate duplicates.\n\t\t\t\twhile (mh.state.length < mh.size) {\n\t\t\t\t\tmh.state.push(new mh.problem.Element());\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn mh;\n\t\t}\n\t}); // declare ParametricalGameClassifierOptimizationProblem\n\n\treturn ParametricalGameClassifierOptimizationProblem;\n};\n"]}